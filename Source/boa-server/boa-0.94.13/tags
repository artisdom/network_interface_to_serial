!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.6	//
ALIAS	src/defines.h	149;"	d
ALIAS_HASHTABLE_SIZE	src/defines.h	47;"	d
BEGIN	src/lex.yy.c	125;"	d	file:
BOA_FD_SET	src/defines.h	177;"	d
BODY_READ	src/defines.h	134;"	d
BODY_WRITE	src/defines.h	135;"	d
BUFFER_SIZE	src/defines.h	44;"	d
BoaConfigStmt	src/boa_grammar.y	/^BoaConfigStmt:		$/;"	l
BoaConfigStmts	src/boa_grammar.y	/^BoaConfigStmts:		BoaConfigStmts BoaConfigStmt$/;"	l
CC	src/Makefile	/^CC = arm-linux-gcc $/;"	m
CFLAGS	src/Makefile	/^CFLAGS = -g -O2 -pipe -Wall -I.$/;"	m
CGI	src/defines.h	144;"	d
CGI_ARGC_MAX	src/defines.h	76;"	d
CGI_BUFFER	src/defines.h	161;"	d
CGI_DONE	src/defines.h	162;"	d
CGI_ENV_MAX	src/defines.h	75;"	d
CGI_MIME_TYPE	src/defines.h	52;"	d
CGI_PARSE	src/defines.h	160;"	d
CGI_VERSION	src/defines.h	73;"	d
CLIENT_STREAM_SIZE	src/defines.h	43;"	d
COMMON_CGI_COUNT	src/defines.h	74;"	d
CONST	src/index_dir.c	45;"	d	file:
CONST	src/index_dir.c	47;"	d	file:
CPP	src/Makefile	/^CPP = arm-linux-gcc -E$/;"	m
CRLF	src/response.c	28;"	d	file:
ConfigFiles	src/boa_grammar.y	/^ConfigFiles:		BoaConfigStmts MimeTypeStmts$/;"	l
DBG	src/config.c	30;"	d	file:
DBG	src/config.c	32;"	d	file:
DBG	src/y.tab.c	108;"	d	file:
DBG	src/y.tab.c	110;"	d	file:
DEAD	src/defines.h	140;"	d
DEFAULT_PATH	src/defines.h	34;"	d
DIE	src/defines.h	195;"	d
DIRBUF_SIZE	src/util.c	479;"	d	file:
DMALLOC_FUNC_CHECK	src/compat.h	132;"	d
DONE	src/defines.h	139;"	d
ECHO	src/lex.yy.c	649;"	d	file:
EOB_ACT_CONTINUE_SCAN	src/lex.yy.c	168;"	d	file:
EOB_ACT_END_OF_FILE	src/lex.yy.c	169;"	d	file:
EOB_ACT_LAST_MATCH	src/lex.yy.c	170;"	d	file:
Extension	src/boa_grammar.y	/^Extension:		STRING$/;"	l
ExtensionList	src/boa_grammar.y	/^ExtensionList:		ExtensionList Extension$/;"	l
FLEXINT_H	src/lex.yy.c	29;"	d	file:
FLEX_BETA	src/lex.yy.c	13;"	d	file:
FLEX_SCANNER	src/lex.yy.c	8;"	d	file:
GCC_FLAGS	src/Makefile	/^GCC_FLAGS = -Wstrict-prototypes -Wpointer-arith -Wcast-align -Wcast-qual\\$/;"	m
GUNZIP	src/acconfig.h	2;"	d
GUNZIP	src/config.h	37;"	d
HAVE_ALPHASORT	src/config.h	49;"	d
HAVE_DIRENT_H	src/config.h	82;"	d
HAVE_FCNTL_H	src/config.h	85;"	d
HAVE_GETCWD	src/config.h	52;"	d
HAVE_GETHOSTBYNAME	src/config.h	55;"	d
HAVE_GETHOSTNAME	src/config.h	58;"	d
HAVE_GETOPT_H	src/config.h	88;"	d
HAVE_GETPAGESIZE	src/config.h	61;"	d
HAVE_INET_ATON	src/config.h	64;"	d
HAVE_LIMITS_H	src/config.h	91;"	d
HAVE_MMAP	src/config.h	11;"	d
HAVE_SCANDIR	src/config.h	67;"	d
HAVE_SELECT	src/config.h	70;"	d
HAVE_SIN_LEN	src/acconfig.h	5;"	d
HAVE_SOCKET	src/config.h	73;"	d
HAVE_STRDUP	src/config.h	76;"	d
HAVE_STRSTR	src/config.h	79;"	d
HAVE_SYS_FCNTL_H	src/config.h	100;"	d
HAVE_SYS_SELECT_H	src/config.h	106;"	d
HAVE_SYS_TIME_H	src/config.h	109;"	d
HAVE_SYS_WAIT_H	src/config.h	14;"	d
HAVE_TM_GMTOFF	src/acconfig.h	11;"	d
HAVE_TM_GMTOFF	src/config.h	43;"	d
HAVE_TM_ZONE	src/acconfig.h	14;"	d
HAVE_TM_ZONE	src/config.h	17;"	d
HAVE_TM_ZONE	src/config.h	46;"	d
HAVE_UNISTD_H	src/config.h	112;"	d
HEX	src/request.c	106;"	d	file:
HEX_TO_DECIMAL	src/util.c	28;"	d	file:
HTML	src/response.c	27;"	d	file:
INITIAL	src/lex.yy.c	555;"	d	file:
INT16_MAX	src/lex.yy.c	71;"	d	file:
INT16_MIN	src/lex.yy.c	62;"	d	file:
INT32_MAX	src/lex.yy.c	74;"	d	file:
INT32_MIN	src/lex.yy.c	65;"	d	file:
INT8_MAX	src/lex.yy.c	68;"	d	file:
INT8_MIN	src/lex.yy.c	59;"	d	file:
INTEGER	src/y.tab.c	/^     INTEGER = 263$/;"	e	enum:yytokentype	file:
INTEGER	src/y.tab.c	160;"	d	file:
INTEGER	src/y.tab.h	/^     INTEGER = 263$/;"	e	enum:yytokentype
INTEGER	src/y.tab.h	56;"	d
INT_TO_HEX	src/buffer.c	27;"	d	file:
INT_TO_HEX	src/index_dir.c	35;"	d	file:
KA_ACTIVE	src/defines.h	157;"	d
KA_INACTIVE	src/defines.h	155;"	d
KA_STOPPED	src/defines.h	156;"	d
LDFLAGS	src/Makefile	/^LDFLAGS =  -g$/;"	m
LEX	src/Makefile	/^LEX = flex $/;"	m
LIBS	src/Makefile	/^LIBS =  $/;"	m
MAP_OPTIONS	src/compat.h	67;"	d
MAP_OPTIONS	src/compat.h	69;"	d
MAX_ACCEPT_LENGTH	src/defines.h	64;"	d
MAX_ACCEPT_LENGTH	src/defines.h	66;"	d
MAX_FILE_LENGTH	src/defines.h	60;"	d
MAX_FILE_LENGTH	src/index_dir.c	32;"	d	file:
MAX_FILE_MMAP	src/defines.h	171;"	d
MAX_HASH_LENGTH	src/hash.c	88;"	d	file:
MAX_HEADER_LENGTH	src/defines.h	42;"	d
MAX_LOG_LENGTH	src/defines.h	59;"	d
MAX_PATH_LENGTH	src/defines.h	61;"	d
MAX_PATH_LENGTH	src/index_dir.c	33;"	d	file:
MAX_SITENAME_LENGTH	src/defines.h	58;"	d
MAX_STR_CONST	src/lex.yy.c	535;"	d	file:
MIME	src/lex.yy.c	556;"	d	file:
MIMETYPE	src/y.tab.c	/^     MIMETYPE = 261,$/;"	e	enum:yytokentype	file:
MIMETYPE	src/y.tab.c	158;"	d	file:
MIMETYPE	src/y.tab.h	/^     MIMETYPE = 261,$/;"	e	enum:yytokentype
MIMETYPE	src/y.tab.h	54;"	d
MIME_HASHTABLE_SIZE	src/defines.h	46;"	d
MMAP_LIST_HASH	src/defines.h	169;"	d
MMAP_LIST_MASK	src/defines.h	166;"	d
MMAP_LIST_NEXT	src/defines.h	168;"	d
MMAP_LIST_SIZE	src/defines.h	165;"	d
MMAP_LIST_USE_MAX	src/defines.h	167;"	d
M_DELETE	src/defines.h	124;"	d
M_GET	src/defines.h	120;"	d
M_HEAD	src/defines.h	121;"	d
M_LINK	src/defines.h	125;"	d
M_POST	src/defines.h	123;"	d
M_PUT	src/defines.h	122;"	d
M_UNLINK	src/defines.h	126;"	d
MimeTypeStmt	src/boa_grammar.y	/^MimeTypeStmt:		MIMETYPE $/;"	l
MimeTypeStmts	src/boa_grammar.y	/^MimeTypeStmts:		MimeTypeStmts MimeTypeStmt$/;"	l
NAMLEN	src/compat.h	84;"	d
NAMLEN	src/compat.h	87;"	d
NEEDS_ESCAPE_BITS	src/escape.h	28;"	d
NEEDS_ESCAPE_INDEX	src/escape.h	36;"	d
NEEDS_ESCAPE_MASK	src/escape.h	39;"	d
NEEDS_ESCAPE_SHIFT	src/acconfig.h	8;"	d
NEEDS_ESCAPE_SHIFT	src/escape.h	31;"	d
NEEDS_ESCAPE_WORD_LENGTH	src/escape.h	34;"	d
NI_MAXHOST	src/compat.h	43;"	d
NOBLOCK	src/compat.h	57;"	d
NOBLOCK	src/compat.h	60;"	d
NPH	src/defines.h	145;"	d
OBJS	src/Makefile	/^OBJS = y.tab.o lex.yy.o $(SOURCES:.c=.o) timestamp.o $/;"	m
ONE_CR	src/defines.h	131;"	d
ONE_LF	src/defines.h	132;"	d
OPEN_MAX	src/compat.h	39;"	d
PASSWD_HASHTABLE_SIZE	src/defines.h	48;"	d
PATH_MAX	src/compat.h	52;"	d
PIPE_READ	src/defines.h	137;"	d
PIPE_WRITE	src/defines.h	138;"	d
READ_HEADER	src/defines.h	130;"	d
REDIRECT	src/defines.h	151;"	d
REJECT	src/lex.yy.c	500;"	d	file:
REQUEST_TIMEOUT	src/defines.h	50;"	d
R_ACCEPTED	src/defines.h	90;"	d
R_BAD_GATEWAY	src/defines.h	113;"	d
R_BAD_REQUEST	src/defines.h	99;"	d
R_BAD_VERSION	src/defines.h	116;"	d
R_CLIENT_ERROR	src/defines.h	83;"	d
R_CONFLICT	src/defines.h	108;"	d
R_CREATED	src/defines.h	89;"	d
R_ERROR	src/defines.h	111;"	d
R_FORBIDDEN	src/defines.h	102;"	d
R_GATEWAY_TO	src/defines.h	115;"	d
R_GONE	src/defines.h	109;"	d
R_INFORMATIONAL	src/defines.h	80;"	d
R_METHOD_NA	src/defines.h	104;"	d
R_MOVED_PERM	src/defines.h	95;"	d
R_MOVED_TEMP	src/defines.h	96;"	d
R_MULTIPLE	src/defines.h	94;"	d
R_NONE_ACC	src/defines.h	105;"	d
R_NOT_FOUND	src/defines.h	103;"	d
R_NOT_IMP	src/defines.h	112;"	d
R_NOT_MODIFIED	src/defines.h	97;"	d
R_NO_CONTENT	src/defines.h	92;"	d
R_PAYMENT	src/defines.h	101;"	d
R_PROVISIONAL	src/defines.h	91;"	d
R_PROXY	src/defines.h	106;"	d
R_REDIRECTION	src/defines.h	82;"	d
R_REQUEST_OK	src/defines.h	88;"	d
R_REQUEST_TO	src/defines.h	107;"	d
R_SERVER_ERROR	src/defines.h	84;"	d
R_SERVICE_UNAV	src/defines.h	114;"	d
R_SUCCESS	src/defines.h	81;"	d
R_UNAUTHORIZED	src/defines.h	100;"	d
S0A	src/config.c	84;"	d	file:
S1A	src/config.c	85;"	d	file:
S2A	src/config.c	86;"	d	file:
SCRIPTALIAS	src/defines.h	150;"	d
SERVER_AF	src/compat.h	75;"	d
SERVER_AF	src/compat.h	79;"	d
SERVER_ROOT	src/defines.h	30;"	d
SERVER_VERSION	src/defines.h	70;"	d
SINGLE_POST_LIMIT_DEFAULT	src/defines.h	37;"	d
SOCKADDR	src/compat.h	73;"	d
SOCKADDR	src/compat.h	77;"	d
SOCKETBUF_SIZE	src/defines.h	41;"	d
SOURCES	src/Makefile	/^SOURCES = alias.c boa.c buffer.c cgi.c cgi_header.c config.c escape.c \\$/;"	m
SO_MAXCONN	src/compat.h	48;"	d
SQUASH_KA	src/defines.h	175;"	d
STDC_HEADERS	src/config.h	28;"	d
STMT_NO_ARGS	src/y.tab.c	/^     STMT_NO_ARGS = 258,$/;"	e	enum:yytokentype	file:
STMT_NO_ARGS	src/y.tab.c	155;"	d	file:
STMT_NO_ARGS	src/y.tab.h	/^     STMT_NO_ARGS = 258,$/;"	e	enum:yytokentype
STMT_NO_ARGS	src/y.tab.h	51;"	d
STMT_ONE_ARG	src/y.tab.c	/^     STMT_ONE_ARG = 259,$/;"	e	enum:yytokentype	file:
STMT_ONE_ARG	src/y.tab.c	156;"	d	file:
STMT_ONE_ARG	src/y.tab.h	/^     STMT_ONE_ARG = 259,$/;"	e	enum:yytokentype
STMT_ONE_ARG	src/y.tab.h	52;"	d
STMT_TWO_ARGS	src/y.tab.c	/^     STMT_TWO_ARGS = 260,$/;"	e	enum:yytokentype	file:
STMT_TWO_ARGS	src/y.tab.c	157;"	d	file:
STMT_TWO_ARGS	src/y.tab.h	/^     STMT_TWO_ARGS = 260,$/;"	e	enum:yytokentype
STMT_TWO_ARGS	src/y.tab.h	53;"	d
STR	src/lex.yy.c	557;"	d	file:
STRING	src/y.tab.c	/^     STRING = 262,$/;"	e	enum:yytokentype	file:
STRING	src/y.tab.c	159;"	d	file:
STRING	src/y.tab.h	/^     STRING = 262,$/;"	e	enum:yytokentype
STRING	src/y.tab.h	55;"	d
S_FAMILY	src/compat.h	74;"	d
S_FAMILY	src/compat.h	78;"	d
StmtNoArgs	src/boa_grammar.y	/^StmtNoArgs:		STMT_NO_ARGS$/;"	l
StmtOneArg	src/boa_grammar.y	/^StmtOneArg:		STMT_ONE_ARG STRING$/;"	l
StmtTwoArgs	src/boa_grammar.y	/^StmtTwoArgs:		STMT_TWO_ARGS STRING$/;"	l
TIMEZONE	src/compat.h	126;"	d
TIMEZONE	src/compat.h	128;"	d
TIMEZONE_OFFSET	src/compat.h	120;"	d
TIMEZONE_OFFSET	src/compat.h	122;"	d
TIME_WITH_SYS_TIME	src/config.h	31;"	d
TWO_CR	src/defines.h	133;"	d
UINT16_MAX	src/lex.yy.c	80;"	d	file:
UINT32_MAX	src/lex.yy.c	83;"	d	file:
UINT8_MAX	src/lex.yy.c	77;"	d	file:
VPATH	src/Makefile	/^VPATH = .:.\/..\/extras$/;"	m
WARN	src/defines.h	196;"	d
WRITE	src/defines.h	136;"	d
YACC	src/Makefile	/^YACC = bison -y $/;"	m
YYABORT	src/y.tab.c	585;"	d	file:
YYACCEPT	src/y.tab.c	584;"	d	file:
YYBACKUP	src/y.tab.c	597;"	d	file:
YYBISON	src/y.tab.c	46;"	d	file:
YYBISON_VERSION	src/y.tab.c	49;"	d	file:
YYCOPY	src/y.tab.c	371;"	d	file:
YYCOPY	src/y.tab.c	374;"	d	file:
YYDEBUG	src/y.tab.c	123;"	d	file:
YYDPRINTF	src/y.tab.c	677;"	d	file:
YYDPRINTF	src/y.tab.c	826;"	d	file:
YYEMPTY	src/y.tab.c	581;"	d	file:
YYEOF	src/y.tab.c	582;"	d	file:
YYERRCODE	src/y.tab.c	616;"	d	file:
YYERROR	src/y.tab.c	586;"	d	file:
YYERROR_VERBOSE	src/y.tab.c	128;"	d	file:
YYERROR_VERBOSE	src/y.tab.c	129;"	d	file:
YYERROR_VERBOSE	src/y.tab.c	131;"	d	file:
YYFAIL	src/y.tab.c	593;"	d	file:
YYFINAL	src/y.tab.c	404;"	d	file:
YYFPRINTF	src/y.tab.c	674;"	d	file:
YYFREE	src/y.tab.c	337;"	d	file:
YYID	src/y.tab.c	/^YYID (int yyi)$/;"	f	file:
YYID	src/y.tab.c	261;"	d	file:
YYINITDEPTH	src/y.tab.c	835;"	d	file:
YYLAST	src/y.tab.c	406;"	d	file:
YYLEX	src/y.tab.c	664;"	d	file:
YYLEX	src/y.tab.c	666;"	d	file:
YYLLOC_DEFAULT	src/y.tab.c	625;"	d	file:
YYLSP_NEEDED	src/y.tab.c	64;"	d	file:
YYMALLOC	src/y.tab.c	330;"	d	file:
YYMAXDEPTH	src/y.tab.c	846;"	d	file:
YYMAXUTOK	src/y.tab.c	419;"	d	file:
YYNNTS	src/y.tab.c	411;"	d	file:
YYNRULES	src/y.tab.c	413;"	d	file:
YYNSTATES	src/y.tab.c	415;"	d	file:
YYNTOKENS	src/y.tab.c	409;"	d	file:
YYPACT_NINF	src/y.tab.c	538;"	d	file:
YYPOPSTACK	src/y.tab.c	1186;"	d	file:
YYPULL	src/y.tab.c	61;"	d	file:
YYPURE	src/y.tab.c	55;"	d	file:
YYPUSH	src/y.tab.c	58;"	d	file:
YYRECOVERING	src/y.tab.c	595;"	d	file:
YYRHSLOC	src/y.tab.c	623;"	d	file:
YYSIZE_MAXIMUM	src/y.tab.c	238;"	d	file:
YYSIZE_T	src/y.tab.c	226;"	d	file:
YYSIZE_T	src/y.tab.c	228;"	d	file:
YYSIZE_T	src/y.tab.c	232;"	d	file:
YYSIZE_T	src/y.tab.c	234;"	d	file:
YYSKELETON_NAME	src/y.tab.c	52;"	d	file:
YYSTACK_ALLOC	src/y.tab.c	284;"	d	file:
YYSTACK_ALLOC	src/y.tab.c	288;"	d	file:
YYSTACK_ALLOC	src/y.tab.c	293;"	d	file:
YYSTACK_ALLOC	src/y.tab.c	316;"	d	file:
YYSTACK_ALLOC_MAXIMUM	src/y.tab.c	313;"	d	file:
YYSTACK_ALLOC_MAXIMUM	src/y.tab.c	319;"	d	file:
YYSTACK_BYTES	src/y.tab.c	363;"	d	file:
YYSTACK_FREE	src/y.tab.c	307;"	d	file:
YYSTACK_FREE	src/y.tab.c	317;"	d	file:
YYSTACK_GAP_MAXIMUM	src/y.tab.c	359;"	d	file:
YYSTACK_RELOCATE	src/y.tab.c	390;"	d	file:
YYSTATE	src/lex.yy.c	132;"	d	file:
YYSTYPE	src/y.tab.c	/^typedef union YYSTYPE$/;"	u	file:
YYSTYPE	src/y.tab.c	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE	file:
YYSTYPE	src/y.tab.h	/^typedef union YYSTYPE$/;"	u
YYSTYPE	src/y.tab.h	/^} YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE_IS_DECLARED	src/y.tab.c	183;"	d	file:
YYSTYPE_IS_DECLARED	src/y.tab.h	79;"	d
YYSTYPE_IS_TRIVIAL	src/y.tab.c	181;"	d	file:
YYSTYPE_IS_TRIVIAL	src/y.tab.h	77;"	d
YYTABLES_NAME	src/lex.yy.c	1959;"	d	file:
YYTABLE_NINF	src/y.tab.c	557;"	d	file:
YYTERROR	src/y.tab.c	615;"	d	file:
YYTOKENTYPE	src/y.tab.c	142;"	d	file:
YYTOKENTYPE	src/y.tab.h	38;"	d
YYTOKEN_TABLE	src/y.tab.c	136;"	d	file:
YYTRANSLATE	src/y.tab.c	421;"	d	file:
YYUNDEFTOK	src/y.tab.c	418;"	d	file:
YYUSE	src/y.tab.c	254;"	d	file:
YYUSE	src/y.tab.c	256;"	d	file:
YY_	src/y.tab.c	244;"	d	file:
YY_	src/y.tab.c	248;"	d	file:
YY_AT_BOL	src/lex.yy.c	339;"	d	file:
YY_BREAK	src/lex.yy.c	728;"	d	file:
YY_BUFFER_EOF_PENDING	src/lex.yy.c	255;"	d	file:
YY_BUFFER_NEW	src/lex.yy.c	243;"	d	file:
YY_BUFFER_NORMAL	src/lex.yy.c	244;"	d	file:
YY_BUFFER_STATE	src/lex.yy.c	/^typedef struct yy_buffer_state *YY_BUFFER_STATE;$/;"	t	typeref:struct:yy_buffer_state	file:
YY_BUF_SIZE	src/lex.yy.c	149;"	d	file:
YY_BUF_SIZE	src/lex.yy.c	151;"	d	file:
YY_CHAR	src/lex.yy.c	/^typedef unsigned char YY_CHAR;$/;"	t	file:
YY_CURRENT_BUFFER	src/lex.yy.c	271;"	d	file:
YY_CURRENT_BUFFER_LVALUE	src/lex.yy.c	278;"	d	file:
YY_DECL	src/lex.yy.c	716;"	d	file:
YY_DECL_IS_OURS	src/lex.yy.c	712;"	d	file:
YY_DO_BEFORE_ACTION	src/lex.yy.c	364;"	d	file:
YY_END_OF_BUFFER	src/lex.yy.c	372;"	d	file:
YY_END_OF_BUFFER_CHAR	src/lex.yy.c	140;"	d	file:
YY_EXIT_FAILURE	src/lex.yy.c	1757;"	d	file:
YY_EXTRA_TYPE	src/lex.yy.c	568;"	d	file:
YY_FATAL_ERROR	src/lex.yy.c	703;"	d	file:
YY_FLEX_MAJOR_VERSION	src/lex.yy.c	9;"	d	file:
YY_FLEX_MINOR_VERSION	src/lex.yy.c	10;"	d	file:
YY_FLEX_SUBMINOR_VERSION	src/lex.yy.c	11;"	d	file:
YY_FLUSH_BUFFER	src/lex.yy.c	307;"	d	file:
YY_INPUT	src/lex.yy.c	656;"	d	file:
YY_INT_ALIGNED	src/lex.yy.c	4;"	d	file:
YY_LESS_LINENO	src/lex.yy.c	172;"	d	file:
YY_LOCATION_PRINT	src/y.tab.c	651;"	d	file:
YY_LOCATION_PRINT	src/y.tab.c	656;"	d	file:
YY_MORE_ADJ	src/lex.yy.c	502;"	d	file:
YY_NEW_FILE	src/lex.yy.c	138;"	d	file:
YY_NULL	src/lex.yy.c	112;"	d	file:
YY_NUM_RULES	src/lex.yy.c	371;"	d	file:
YY_READ_BUF_SIZE	src/lex.yy.c	638;"	d	file:
YY_READ_BUF_SIZE	src/lex.yy.c	640;"	d	file:
YY_REDUCE_PRINT	src/y.tab.c	816;"	d	file:
YY_REDUCE_PRINT	src/y.tab.c	829;"	d	file:
YY_RESTORE_YY_MORE_OFFSET	src/lex.yy.c	503;"	d	file:
YY_RULE_SETUP	src/lex.yy.c	731;"	d	file:
YY_SC_TO_UI	src/lex.yy.c	119;"	d	file:
YY_STACK_PRINT	src/y.tab.c	778;"	d	file:
YY_STACK_PRINT	src/y.tab.c	828;"	d	file:
YY_START	src/lex.yy.c	131;"	d	file:
YY_START_STACK_INCR	src/lex.yy.c	698;"	d	file:
YY_STATE_BUF_SIZE	src/lex.yy.c	157;"	d	file:
YY_STATE_EOF	src/lex.yy.c	135;"	d	file:
YY_STRUCT_YY_BUFFER_STATE	src/lex.yy.c	196;"	d	file:
YY_SYMBOL_PRINT	src/y.tab.c	683;"	d	file:
YY_SYMBOL_PRINT	src/y.tab.c	827;"	d	file:
YY_TYPEDEF_YY_BUFFER_STATE	src/lex.yy.c	160;"	d	file:
YY_TYPEDEF_YY_SIZE_T	src/lex.yy.c	191;"	d	file:
YY_USER_ACTION	src/lex.yy.c	723;"	d	file:
YY_USE_CONST	src/lex.yy.c	100;"	d	file:
YY_USE_CONST	src/lex.yy.c	93;"	d	file:
_BOA_H	src/boa.h	26;"	d
_COMPAT_H	src/compat.h	26;"	d
_DEFINES_H	src/defines.h	25;"	d
_GLOBALS_H	src/globals.h	26;"	d
_STDLIB_H	src/y.tab.c	298;"	d	file:
_STDLIB_H	src/y.tab.c	326;"	d	file:
__STDC_LIMIT_MACROS	src/lex.yy.c	39;"	d	file:
_hash_struct_	src/hash.c	/^struct _hash_struct_ {$/;"	s	file:
_needs_escape	src/escape.c	/^unsigned long _needs_escape[(NEEDS_ESCAPE_BITS+NEEDS_ESCAPE_WORD_LENGTH-1)\/NEEDS_ESCAPE_WORD_LENGTH];$/;"	v
accept	src/globals.h	/^    char accept[MAX_ACCEPT_LENGTH]; \/* Accept: fields *\/$/;"	m	struct:request
access_log	src/log.c	/^FILE *access_log;$/;"	v
access_log_name	src/config.c	/^char *access_log_name;$/;"	v
access_log_name	src/log.c	/^char *access_log_name;$/;"	v
action	src/parse.h	/^    void (*action) (char *, char *, void *);$/;"	m	struct:ccommand
add_accept_header	src/request.c	/^void add_accept_header(request * req, char *mime_type)$/;"	f
add_alias	src/alias.c	/^void add_alias(char *fakename, char *realname, int type)$/;"	f
add_cgi_env	src/cgi.c	/^int add_cgi_env(request * req, char *key, char *value, int http_prefix)$/;"	f
add_mime_type	src/hash.c	/^void add_mime_type(char *extension, char *type)$/;"	f
alias	src/globals.h	/^struct alias {$/;"	s
alias	src/globals.h	/^typedef struct alias alias;$/;"	t	typeref:struct:alias
alias_hashtable	src/alias.c	/^static alias *alias_hashtable[ALIAS_HASHTABLE_SIZE];$/;"	v	file:
alias_number	src/config.c	/^static int alias_number = ALIAS;$/;"	v	file:
alloca	src/y.tab.c	291;"	d	file:
alphasort	extras/alphasort.c	/^int alphasort(const struct dirent **a, const struct dirent **b)$/;"	f
arg1hold	src/y.tab.c	/^char *arg1hold;$/;"	v
ascii_sockaddr	src/ip.c	/^char *ascii_sockaddr(struct SOCKADDR *s, char *dest, int len)$/;"	f
backlog	src/boa.c	/^int backlog = SO_MAXCONN;$/;"	v
bind_server	src/ip.c	/^int bind_server(int server_s, char *server_ip)$/;"	f
block_read_fdset	src/select.c	/^fd_set block_read_fdset;$/;"	v
block_request	src/queue.c	/^void block_request(request * req)$/;"	f
block_write_fdset	src/select.c	/^fd_set block_write_fdset;$/;"	v
boa_atoi	src/util.c	/^int boa_atoi(char *s)$/;"	f
boa_hash	src/hash.c	55;"	d	file:
boa_hash	src/hash.c	59;"	d	file:
boa_hash	src/hash.c	62;"	d	file:
boa_perror	src/log.c	/^void boa_perror(request * req, char *message)$/;"	f
buffer	src/globals.h	/^    char buffer[BUFFER_SIZE + 1]; \/* generic I\/O buffer *\/$/;"	m	struct:request
buffer_end	src/globals.h	/^    int buffer_end;             \/* where the buffer ends *\/$/;"	m	struct:request
buffer_start	src/globals.h	/^    int buffer_start;           \/* where the buffer starts *\/$/;"	m	struct:request
build_needs_escape	src/escape.c	/^void build_needs_escape(void)$/;"	f
c_add_alias	src/config.c	/^static void c_add_alias(char *v1, char *v2, void *t)$/;"	f	file:
c_add_type	src/config.c	/^static void c_add_type(char *v1, char *v2, void *t)$/;"	f	file:
c_set_group	src/config.c	/^static void c_set_group(char *v1, char *v2, void *t)$/;"	f	file:
c_set_int	src/config.c	/^static void c_set_int(char *v1, char *v2, void *t)$/;"	f	file:
c_set_string	src/config.c	/^static void c_set_string(char *v1, char *v2, void *t)$/;"	f	file:
c_set_unity	src/config.c	/^static void c_set_unity(char *v1, char *v2, void *t)$/;"	f	file:
c_set_user	src/config.c	/^static void c_set_user(char *v1, char *v2, void *t)$/;"	f	file:
cachedir	src/config.c	/^char *cachedir;$/;"	v
ccommand	src/parse.h	/^struct ccommand {$/;"	s
cgi_env	src/globals.h	/^    char *cgi_env[CGI_ENV_MAX + 4];             \/* CGI environment *\/$/;"	m	struct:request
cgi_env_index	src/globals.h	/^    int cgi_env_index;          \/* index into array *\/$/;"	m	struct:request
cgi_log_fd	src/log.c	/^int cgi_log_fd;$/;"	v
cgi_log_name	src/config.c	/^char *cgi_log_name;$/;"	v
cgi_log_name	src/log.c	/^char *cgi_log_name;$/;"	v
cgi_path	src/config.c	/^char *cgi_path = NULL;$/;"	v
cgi_status	src/globals.h	/^    int cgi_status;$/;"	m	struct:request
clean_pathname	src/util.c	/^void clean_pathname(char *pathname)$/;"	f
clear_common_env	src/cgi.c	/^void clear_common_env(void)$/;"	f
client_stream	src/globals.h	/^    char client_stream[CLIENT_STREAM_SIZE]; \/* data from client - fit or be hosed *\/$/;"	m	struct:request
client_stream_pos	src/globals.h	/^    int client_stream_pos;      \/* how much have we read... *\/$/;"	m	struct:request
clist	src/config.c	/^struct ccommand clist[] = {$/;"	v	typeref:struct:ccommand
close_access_log	src/log.c	/^void close_access_log(void)$/;"	f
common_cgi_env	src/cgi.c	/^static char *common_cgi_env[COMMON_CGI_COUNT + 1];$/;"	v	file:
complete_env	src/cgi.c	/^int complete_env(request * req)$/;"	f
content_length	src/globals.h	/^    char *content_length;       \/* env variable *\/$/;"	m	struct:request
content_type	src/globals.h	/^    char *content_type;         \/* env variable *\/$/;"	m	struct:request
create_argv	src/cgi.c	/^void create_argv(request * req, char **aargv)$/;"	f
create_common_env	src/cgi.c	/^void create_common_env()$/;"	f
create_server_socket	src/boa.c	/^static int create_server_socket(void)$/;"	f	file:
create_temporary_file	src/util.c	/^int create_temporary_file(short want_unlink, char *storage, int size)$/;"	f
current_time	src/boa.c	/^time_t current_time;$/;"	v
current_uid	src/config.c	/^static uid_t current_uid=0;$/;"	v	file:
cval	src/y.tab.c	/^    struct ccommand * cval;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::ccommand	file:
cval	src/y.tab.h	/^    struct ccommand * cval;$/;"	m	union:YYSTYPE	typeref:struct:YYSTYPE::ccommand
data_fd	src/globals.h	/^    int data_fd;                \/* fd of data *\/$/;"	m	struct:request
data_mem	src/globals.h	/^    char *data_mem;             \/* mmapped\/malloced char array *\/$/;"	m	struct:request
day_tab	src/util.c	/^const char day_tab[] = "Sun,Mon,Tue,Wed,Thu,Fri,Sat,";$/;"	v
default_type	src/config.c	/^char *default_type;$/;"	v
dequeue	src/queue.c	/^void dequeue(request ** head, request * req)$/;"	f
dev	src/globals.h	/^    dev_t dev;$/;"	m	struct:mmap_entry
devnullfd	src/boa.c	/^int devnullfd = -1;$/;"	v
directory_index	src/config.c	/^char *directory_index;$/;"	v
dirent	src/compat.h	86;"	d
dirmaker	src/config.c	/^char *dirmaker;$/;"	v
djb2_hash	src/hash.c	/^static unsigned djb2_hash(char *str)$/;"	f	file:
dmalloc_shutdown	src/configure	/^dmalloc_shutdown()$/;"	f
do_fork	src/boa.c	/^static int do_fork = 1;$/;"	v	file:
document_root	src/config.c	/^char *document_root;$/;"	v
drop_privs	src/boa.c	/^static void drop_privs(void)$/;"	f	file:
dump_alias	src/alias.c	/^void dump_alias(void)$/;"	f
dump_mime	src/hash.c	/^void dump_mime(void)$/;"	f
dump_passwd	src/hash.c	/^void dump_passwd(void)$/;"	f
enqueue	src/queue.c	/^void enqueue(request ** head, request * req)$/;"	f
env	src/signals.c	/^sigjmp_buf env;$/;"	v
env_gen_extra	src/cgi.c	/^static char *env_gen_extra(const char *key, const char *value, int extra)$/;"	f	file:
error_log_name	src/config.c	/^char *error_log_name;$/;"	v
error_log_name	src/log.c	/^char *error_log_name;$/;"	v
errors	src/globals.h	/^    long errors;$/;"	m	struct:status
escape_string	src/buffer.c	/^char *escape_string(char *inp, char *buf)$/;"	f
fake_len	src/globals.h	/^    int fake_len;               \/* strlen of fakename *\/$/;"	m	struct:alias
fakename	src/globals.h	/^    char *fakename;             \/* URI path to file *\/$/;"	m	struct:alias
fd	src/globals.h	/^    int fd;                     \/* client's socket fd *\/$/;"	m	struct:request
fdset_update	src/select.c	/^static void fdset_update(void)$/;"	f	file:
file	src/lex.yy.c	/^static int file = 0;$/;"	v	file:
filepos	src/globals.h	/^    unsigned long filepos;      \/* position in file *\/$/;"	m	struct:request
filesize	src/globals.h	/^    unsigned long filesize;     \/* filesize *\/$/;"	m	struct:request
find_alias	src/alias.c	/^alias *find_alias(char *uri, int urilen)$/;"	f
find_mmap	src/mmap_cache.c	/^struct mmap_entry *find_mmap(int data_fd, struct stat *s)$/;"	f
find_named_mmap	src/mmap_cache.c	/^struct mmap_entry *find_named_mmap(char *fname)$/;"	f
fixup_server_root	src/boa.c	/^static void fixup_server_root()$/;"	f	file:
flex_int16_t	src/lex.yy.c	/^typedef int16_t flex_int16_t;$/;"	t	file:
flex_int16_t	src/lex.yy.c	/^typedef short int flex_int16_t;$/;"	t	file:
flex_int32_t	src/lex.yy.c	/^typedef int flex_int32_t;$/;"	t	file:
flex_int32_t	src/lex.yy.c	/^typedef int32_t flex_int32_t;$/;"	t	file:
flex_int8_t	src/lex.yy.c	/^typedef int8_t flex_int8_t;$/;"	t	file:
flex_int8_t	src/lex.yy.c	/^typedef signed char flex_int8_t;$/;"	t	file:
flex_uint16_t	src/lex.yy.c	/^typedef uint16_t flex_uint16_t;$/;"	t	file:
flex_uint16_t	src/lex.yy.c	/^typedef unsigned short int flex_uint16_t;$/;"	t	file:
flex_uint32_t	src/lex.yy.c	/^typedef uint32_t flex_uint32_t;$/;"	t	file:
flex_uint32_t	src/lex.yy.c	/^typedef unsigned int flex_uint32_t;$/;"	t	file:
flex_uint8_t	src/lex.yy.c	/^typedef uint8_t flex_uint8_t;$/;"	t	file:
flex_uint8_t	src/lex.yy.c	/^typedef unsigned char flex_uint8_t; $/;"	t	file:
fopen_gen_fd	src/log.c	/^FILE *fopen_gen_fd(char *spec, const char *mode)$/;"	f
four_char_hash	src/hash.c	/^static unsigned four_char_hash(char *buf)$/;"	f	file:
free_request	src/request.c	/^static void free_request(request ** list_head_addr, request * req)$/;"	f	file:
free_requests	src/request.c	/^void free_requests(void)$/;"	f
get_alias_hash_value	src/alias.c	/^int get_alias_hash_value(char *file)$/;"	f
get_cachedir_file	src/get.c	/^int get_cachedir_file(request * req, struct stat *statbuf)$/;"	f
get_commonlog_time	src/util.c	/^char *get_commonlog_time(void)$/;"	f
get_dir	src/get.c	/^int get_dir(request * req, struct stat *statbuf)$/;"	f
get_home_dir	src/hash.c	/^char *get_home_dir(char *name)$/;"	f
get_homedir_hash_value	src/hash.c	/^unsigned get_homedir_hash_value(char *name)$/;"	f
get_mime_hash_value	src/hash.c	/^unsigned get_mime_hash_value(char *extension)$/;"	f
get_mime_type	src/hash.c	/^char *get_mime_type(char *filename)$/;"	f
get_request	src/request.c	/^void get_request(int server_s)$/;"	f
gethostbyname	src/configure	/^gethostbyname()$/;"	f
gethostname	src/configure	/^gethostname()$/;"	f
handle_sigbus	src/signals.c	/^int handle_sigbus;$/;"	v
hash_struct	src/hash.c	/^typedef struct _hash_struct_ hash_struct;$/;"	t	typeref:struct:_hash_struct_	file:
header_end	src/globals.h	/^    char *header_end;           \/* last known end of header, or end of processed data *\/$/;"	m	struct:request
header_line	src/globals.h	/^    char *header_line;          \/* beginning of un or incompletely processed header line *\/$/;"	m	struct:request
header_referer	src/globals.h	/^    char *header_referer;$/;"	m	struct:request
header_user_agent	src/globals.h	/^    char *header_user_agent;$/;"	m	struct:request
html_escape_string	src/index_dir.c	/^char *html_escape_string(char *inp, char *dest, const int len)$/;"	f
http_escape_string	src/index_dir.c	/^char *http_escape_string(char *inp, char *buf, const int len)$/;"	f
http_version	src/globals.h	/^    char *http_version;         \/* HTTP\/?.? of req *\/$/;"	m	struct:request
if_modified_since	src/globals.h	/^    char *if_modified_since;    \/* If-Modified-Since *\/$/;"	m	struct:request
index_directory	src/get.c	/^int index_directory(request * req, char *dest_filename)$/;"	f
index_directory	src/index_dir.c	/^int index_directory(char *dir, char *title)$/;"	f
inet_aton	src/configure	/^inet_aton()$/;"	f
init_cgi	src/cgi.c	/^int init_cgi(request * req)$/;"	f
init_get	src/get.c	/^int init_get(request * req)$/;"	f
init_script_alias	src/alias.c	/^int init_script_alias(request * req, alias * current1, int uri_len)$/;"	f
init_signals	src/signals.c	/^void init_signals(void)$/;"	f
ino	src/globals.h	/^    ino_t ino;$/;"	m	struct:mmap_entry
is_cgi	src/globals.h	/^    int is_cgi;                 \/* true if CGI\/NPH *\/$/;"	m	struct:request
ival	src/y.tab.c	/^    int		ival;$/;"	m	union:YYSTYPE	file:
ival	src/y.tab.h	/^    int		ival;$/;"	m	union:YYSTYPE
k	src/lex.yy.c	/^struct ccommand *k; $/;"	v	typeref:struct:ccommand
ka_max	src/config.c	/^int ka_max;$/;"	v
ka_timeout	src/config.c	/^int ka_timeout;$/;"	v
kacount	src/globals.h	/^    int kacount;                \/* keepalive count *\/$/;"	m	struct:request
keepalive	src/globals.h	/^    int keepalive;              \/* keepalive status *\/$/;"	m	struct:request
key	src/hash.c	/^    char *key;$/;"	m	struct:_hash_struct_	file:
last_modified	src/globals.h	/^    time_t last_modified;       \/* Last-modified: *\/$/;"	m	struct:request
len	src/globals.h	/^    size_t len;$/;"	m	struct:mmap_entry
lineno	src/lex.yy.c	/^int lineno = 1;$/;"	v
local_ip_addr	src/globals.h	/^    char local_ip_addr[NI_MAXHOST]; \/* for virtualhost *\/$/;"	m	struct:request
log_access	src/log.c	/^void log_access(request * req)$/;"	f
log_error_doc	src/log.c	/^void log_error_doc(request * req)$/;"	f
log_error_mesg	src/log.c	/^void log_error_mesg(char *file, int line, char *mesg)$/;"	f
log_error_time	src/log.c	/^void log_error_time()$/;"	f
logline	src/globals.h	/^    char *logline;              \/* line to log file *\/$/;"	m	struct:request
lookup_keyword	src/config.c	/^struct ccommand *lookup_keyword(char *c)$/;"	f
main	src/boa.c	/^int main(int argc, char **argv)$/;"	f
main	src/escape.c	/^int main(void)$/;"	f
main	src/index_dir.c	/^int main(int argc, char *argv[])$/;"	f
main	src/sublog.c	/^int main(int argc, char *argv[])$/;"	f
max_connections	src/config.c	/^long int max_connections;$/;"	v
max_fd	src/boa.c	/^int max_fd = 0;$/;"	v
method	src/globals.h	/^    int method;                 \/* M_GET, M_POST, etc. *\/$/;"	m	struct:request
mime_hashtable	src/hash.c	/^static hash_struct *mime_hashtable[MIME_HASHTABLE_SIZE];$/;"	v	file:
mime_type	src/y.tab.c	/^char mime_type[256];            \/* global to inherit *\/$/;"	v
mime_types	src/lex.yy.c	/^char *mime_types = NULL;$/;"	v
mmap	src/globals.h	/^    char *mmap;$/;"	m	struct:mmap_entry
mmap_entry	src/globals.h	/^struct mmap_entry {$/;"	s
mmap_entry_var	src/globals.h	/^    struct mmap_entry *mmap_entry_var;$/;"	m	struct:request	typeref:struct:request::mmap_entry
mmap_list	src/mmap_cache.c	/^static struct mmap_entry mmap_list[MMAP_LIST_SIZE];$/;"	v	typeref:struct:mmap_entry	file:
mmap_list_entries_used	src/mmap_cache.c	/^int mmap_list_entries_used = 0;$/;"	v
mmap_list_hash_bounces	src/mmap_cache.c	/^int mmap_list_hash_bounces = 0;$/;"	v
mmap_list_total_requests	src/mmap_cache.c	/^int mmap_list_total_requests = 0;$/;"	v
modified_since	src/util.c	/^int modified_since(time_t * mtime, char *if_modified_since)$/;"	f
month2int	src/util.c	/^int month2int(char *monthname)$/;"	f
month_tab	src/util.c	/^const char month_tab[48] =$/;"	v
my_add_cgi_env	src/cgi.c	176;"	d	file:
name	src/parse.h	/^    char *name;$/;"	m	struct:ccommand
needs_escape	src/escape.h	44;"	d
net_port	src/ip.c	/^int net_port(struct SOCKADDR *s)$/;"	f
new_request	src/request.c	/^request *new_request(void)$/;"	f
next	src/globals.h	/^    struct alias *next;$/;"	m	struct:alias	typeref:struct:alias::alias
next	src/globals.h	/^    struct request *next;       \/* next *\/$/;"	m	struct:request	typeref:struct:request::request
next	src/hash.c	/^    struct _hash_struct_ *next;$/;"	m	struct:_hash_struct_	typeref:struct:_hash_struct_::_hash_struct_	file:
normalize_path	src/util.c	/^char * normalize_path(char *path)$/;"	f
object	src/parse.h	/^    void *object;$/;"	m	struct:ccommand
open_gen_fd	src/sublog.c	/^int open_gen_fd(char *spec)$/;"	f
open_logs	src/log.c	/^void open_logs(void)$/;"	f
open_net_fd	src/sublog.c	/^int open_net_fd(char *spec)$/;"	f
open_pipe_fd	src/sublog.c	/^int open_pipe_fd(char *command)$/;"	f
opendir	src/configure	/^opendir()$/;"	f
parse_pos	src/globals.h	/^    int parse_pos;              \/* how much have we parsed *\/$/;"	m	struct:request
passwd_hashtable	src/hash.c	/^static hash_struct *passwd_hashtable[PASSWD_HASHTABLE_SIZE];$/;"	v	file:
path_info	src/globals.h	/^    char *path_info;            \/* env variable *\/$/;"	m	struct:request
path_translated	src/globals.h	/^    char *path_translated;      \/* env variable *\/$/;"	m	struct:request
pathname	src/globals.h	/^    char *pathname;             \/* pathname of requested file *\/$/;"	m	struct:request
pending_requests	src/boa.c	/^int pending_requests = 0;$/;"	v
post_data_fd	src/globals.h	/^    int post_data_fd;           \/* fd for post data tmpfile *\/$/;"	m	struct:request
prev	src/globals.h	/^    struct request *prev;       \/* previous *\/$/;"	m	struct:request	typeref:struct:request::request
print_content_length	src/response.c	/^void print_content_length(request * req)$/;"	f
print_content_type	src/response.c	/^void print_content_type(request * req)$/;"	f
print_http_headers	src/response.c	/^void print_http_headers(request * req)$/;"	f
print_ka_phrase	src/response.c	/^void print_ka_phrase(request * req)$/;"	f
print_last_modified	src/response.c	/^void print_last_modified(request * req)$/;"	f
process_cgi_header	src/cgi_header.c	/^int process_cgi_header(request * req)$/;"	f
process_get	src/get.c	/^int process_get(request * req)$/;"	f
process_header_end	src/request.c	/^int process_header_end(request * req)$/;"	f
process_logline	src/request.c	/^int process_logline(request * req)$/;"	f
process_option_line	src/request.c	/^int process_option_line(request * req)$/;"	f
process_requests	src/request.c	/^void process_requests(int server_s)$/;"	f
qspush	src/lex.yy.c	536;"	d	file:
query_string	src/globals.h	/^    char *query_string;         \/* env variable *\/$/;"	m	struct:request
read_body	src/read.c	/^int read_body(request * req)$/;"	f
read_config_files	src/config.c	/^void read_config_files(void)$/;"	f
read_from_pipe	src/pipe.c	/^int read_from_pipe(request * req)$/;"	f
read_header	src/read.c	/^int read_header(request * req)$/;"	f
ready_request	src/queue.c	/^void ready_request(request * req)$/;"	f
real_len	src/globals.h	/^    int real_len;               \/* strlen of realname *\/$/;"	m	struct:alias
real_set_block_fd	src/util.c	/^int real_set_block_fd(int fd)$/;"	f
real_set_nonblock_fd	src/util.c	/^int real_set_nonblock_fd(int fd)$/;"	f
realname	src/globals.h	/^    char *realname;             \/* Actual path to file *\/$/;"	m	struct:alias
redirect_number	src/config.c	/^static int redirect_number = REDIRECT;$/;"	v	file:
release_mmap	src/mmap_cache.c	/^void release_mmap(struct mmap_entry *e)$/;"	f
remote_ip_addr	src/globals.h	/^    char remote_ip_addr[NI_MAXHOST]; \/* after inet_ntoa *\/$/;"	m	struct:request
remote_port	src/globals.h	/^    int remote_port;            \/* could be used for ident *\/$/;"	m	struct:request
req_flush	src/buffer.c	/^int req_flush(request * req)$/;"	f
req_timeout	src/select.c	/^static struct timeval req_timeout;     \/* timeval for select *\/$/;"	v	typeref:struct:timeval	file:
req_write	src/buffer.c	/^int req_write(request * req, char *msg)$/;"	f
req_write_escape_html	src/buffer.c	/^int req_write_escape_html(request * req, char *msg)$/;"	f
req_write_escape_http	src/buffer.c	/^int req_write_escape_http(request * req, char *msg)$/;"	f
request	src/globals.h	/^struct request {                \/* pending requests *\/$/;"	s
request	src/globals.h	/^typedef struct request request;$/;"	t	typeref:struct:request
request_block	src/queue.c	/^request *request_block = NULL;  \/* blocked list head *\/$/;"	v
request_free	src/queue.c	/^request *request_free = NULL;   \/* free list head *\/$/;"	v
request_ready	src/queue.c	/^request *request_ready = NULL;  \/* ready list head *\/$/;"	v
request_uri	src/globals.h	/^    char request_uri[MAX_HEADER_LENGTH + 1]; \/* uri *\/$/;"	m	struct:request
requests	src/globals.h	/^    long requests;$/;"	m	struct:status
reset_output_buffer	src/buffer.c	/^void reset_output_buffer(request *req)$/;"	f
response_status	src/globals.h	/^    int response_status;        \/* R_NOT_FOUND etc. *\/$/;"	m	struct:request
rfc822_time_buf	src/util.c	/^void rfc822_time_buf(char *buf, time_t s)$/;"	f
scandir	extras/scandir.c	/^scandir(const char *dir, struct dirent ***namelist,$/;"	f
script_name	src/globals.h	/^    char *script_name;          \/* env variable *\/$/;"	m	struct:request
script_number	src/config.c	/^static int script_number = SCRIPTALIAS;$/;"	v	file:
sdbm_hash	src/hash.c	/^static unsigned sdbm_hash(char *str)$/;"	f	file:
select_files	src/index_dir.c	/^int select_files(CONST struct dirent *dirbuf)$/;"	f
select_loop	src/select.c	/^void select_loop(int server_s)$/;"	f
send_error	src/index_dir.c	/^void send_error(int error)$/;"	f
send_r_bad_gateway	src/response.c	/^void send_r_bad_gateway(request * req)$/;"	f
send_r_bad_request	src/response.c	/^void send_r_bad_request(request * req)$/;"	f
send_r_bad_version	src/response.c	/^void send_r_bad_version(request * req)$/;"	f
send_r_error	src/response.c	/^void send_r_error(request * req)$/;"	f
send_r_forbidden	src/response.c	/^void send_r_forbidden(request * req)$/;"	f
send_r_moved_perm	src/response.c	/^void send_r_moved_perm(request * req, char *url)$/;"	f
send_r_moved_temp	src/response.c	/^void send_r_moved_temp(request * req, char *url, char *more_hdr)$/;"	f
send_r_not_found	src/response.c	/^void send_r_not_found(request * req)$/;"	f
send_r_not_implemented	src/response.c	/^void send_r_not_implemented(request * req)$/;"	f
send_r_not_modified	src/response.c	/^void send_r_not_modified(request * req)$/;"	f
send_r_request_ok	src/response.c	/^void send_r_request_ok(request * req)$/;"	f
send_r_service_unavailable	src/response.c	/^void send_r_service_unavailable(request * req) \/* 503 *\/$/;"	f
send_r_unauthorized	src/response.c	/^void send_r_unauthorized(request * req, char *realm_name)$/;"	f
server_admin	src/config.c	/^char *server_admin;$/;"	v
server_gid	src/config.c	/^gid_t server_gid;$/;"	v
server_ip	src/config.c	/^char *server_ip;$/;"	v
server_name	src/config.c	/^char *server_name;$/;"	v
server_port	src/config.c	/^int server_port;$/;"	v
server_root	src/config.c	/^char *server_root;$/;"	v
server_uid	src/config.c	/^uid_t server_uid;$/;"	v
set_block_fd	src/defines.h	188;"	d
set_block_fd	src/defines.h	191;"	d
set_nonblock_fd	src/defines.h	189;"	d
set_nonblock_fd	src/defines.h	192;"	d
short	src/y.tab.c	194;"	d	file:
show_hash_stats	src/hash.c	/^void show_hash_stats(void)$/;"	f
sigalrm	src/signals.c	/^void sigalrm(int dummy)$/;"	f
sigalrm_flag	src/boa.c	/^int sigalrm_flag = 0;           \/* 1 => signal has happened, needs attention *\/$/;"	v
sigalrm_run	src/signals.c	/^void sigalrm_run(void)$/;"	f
sigbus	src/signals.c	/^void sigbus(int dummy)$/;"	f
sigchld	src/signals.c	/^void sigchld(int dummy)$/;"	f
sigchld_flag	src/boa.c	/^int sigchld_flag = 0;           \/* 1 => signal has happened, needs attention *\/$/;"	v
sigchld_run	src/signals.c	/^void sigchld_run(void)$/;"	f
sighup	src/signals.c	/^void sighup(int dummy)$/;"	f
sighup_flag	src/boa.c	/^int sighup_flag = 0;            \/* 1 => signal has happened, needs attention *\/$/;"	v
sighup_run	src/signals.c	/^void sighup_run(void)$/;"	f
sigint	src/signals.c	/^void sigint(int dummy)$/;"	f
sigsegv	src/signals.c	/^void sigsegv(int dummy)$/;"	f
sigterm	src/signals.c	/^void sigterm(int dummy)$/;"	f
sigterm_flag	src/boa.c	/^int sigterm_flag = 0;           \/* lame duck mode *\/$/;"	v
sigterm_stage1_run	src/signals.c	/^void sigterm_stage1_run(int server_s) \/* lame duck mode *\/$/;"	f
sigterm_stage2_run	src/signals.c	/^void sigterm_stage2_run() \/* lame duck mode *\/$/;"	f
simple	src/globals.h	/^    int simple;                 \/* simple request? *\/$/;"	m	struct:request
simple_itoa	src/util.c	/^char *simple_itoa(unsigned int i)$/;"	f
single_post_limit	src/config.c	/^int single_post_limit = SINGLE_POST_LIMIT_DEFAULT;$/;"	v
sock_opt	src/boa.c	/^static int sock_opt = 1;$/;"	v	file:
sockbufsize	src/request.c	/^static int sockbufsize = SOCKETBUF_SIZE;$/;"	v	file:
socket	src/configure	/^socket()$/;"	f
srcdir	src/Makefile	/^srcdir = .$/;"	m
start_time	src/boa.c	/^time_t start_time;$/;"	v
status	src/globals.h	/^    int status;                 \/* see #defines.h *\/$/;"	m	struct:request
status	src/globals.h	/^struct status {$/;"	s
status	src/request.c	/^struct status status;$/;"	v	typeref:struct:status
strdup	extras/strutil.c	/^char *strdup(char *s)$/;"	f
string_buf	src/lex.yy.c	/^char string_buf[MAX_STR_CONST];$/;"	v
string_buf_ptr	src/lex.yy.c	/^char *string_buf_ptr;$/;"	v
strstr	extras/strutil.c	/^char *strstr(char *s1, char *s2)$/;"	f
sval	src/y.tab.c	/^    char *	sval;$/;"	m	union:YYSTYPE	file:
sval	src/y.tab.h	/^    char *	sval;$/;"	m	union:YYSTYPE
tempdir	src/config.c	/^char *tempdir;$/;"	v
time_last	src/globals.h	/^    time_t time_last;           \/* time of last succ. op. *\/$/;"	m	struct:request
timestamp	src/timestamp.c	/^void timestamp(void)$/;"	f
to_upper	src/util.c	/^char *to_upper(char *str)$/;"	f
total_connections	src/request.c	/^int total_connections;$/;"	v
translate_uri	src/alias.c	/^int translate_uri(request * req)$/;"	f
type	src/globals.h	/^    int type;                   \/* ALIAS, SCRIPTALIAS, REDIRECT *\/$/;"	m	struct:alias
type	src/parse.h	/^    int type;$/;"	m	struct:ccommand
unescape_uri	src/util.c	/^int unescape_uri(char *uri, char ** query_string)$/;"	f
unput	src/lex.yy.c	188;"	d	file:
use_count	src/globals.h	/^    int use_count;$/;"	m	struct:mmap_entry
use_localtime	src/config.c	/^int use_localtime;$/;"	v
user_dir	src/config.c	/^char *user_dir;$/;"	v
value	src/hash.c	/^    char *value;$/;"	m	struct:_hash_struct_	file:
verbose_cgi_logs	src/cgi.c	/^int verbose_cgi_logs = 0;$/;"	v
virtualhost	src/config.c	/^int virtualhost;$/;"	v
write_body	src/read.c	/^int write_body(request * req)$/;"	f
write_from_pipe	src/pipe.c	/^int write_from_pipe(request * req)$/;"	f
yy_accept	src/lex.yy.c	/^static yyconst flex_int16_t yy_accept[49] =$/;"	v	file:
yy_at_bol	src/lex.yy.c	/^	int yy_at_bol;$/;"	m	struct:yy_buffer_state	file:
yy_base	src/lex.yy.c	/^static yyconst flex_int16_t yy_base[64] =$/;"	v	file:
yy_bs_column	src/lex.yy.c	/^    int yy_bs_column; \/**< The column count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_bs_lineno	src/lex.yy.c	/^    int yy_bs_lineno; \/**< The line count. *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_pos	src/lex.yy.c	/^	char *yy_buf_pos;		\/* current position in input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_buf_size	src/lex.yy.c	/^	yy_size_t yy_buf_size;$/;"	m	struct:yy_buffer_state	file:
yy_buffer_stack	src/lex.yy.c	/^static YY_BUFFER_STATE * yy_buffer_stack = 0; \/**< Stack as an array. *\/$/;"	v	file:
yy_buffer_stack_max	src/lex.yy.c	/^static size_t yy_buffer_stack_max = 0; \/**< capacity of stack. *\/$/;"	v	file:
yy_buffer_stack_top	src/lex.yy.c	/^static size_t yy_buffer_stack_top = 0; \/**< index of top of stack. *\/$/;"	v	file:
yy_buffer_state	src/lex.yy.c	/^struct yy_buffer_state$/;"	s	file:
yy_buffer_status	src/lex.yy.c	/^	int yy_buffer_status;$/;"	m	struct:yy_buffer_state	file:
yy_c_buf_p	src/lex.yy.c	/^static char *yy_c_buf_p = (char *) 0;$/;"	v	file:
yy_ch_buf	src/lex.yy.c	/^	char *yy_ch_buf;		\/* input buffer *\/$/;"	m	struct:yy_buffer_state	file:
yy_chk	src/lex.yy.c	/^static yyconst flex_int16_t yy_chk[157] =$/;"	v	file:
yy_create_buffer	src/lex.yy.c	/^    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )$/;"	f
yy_def	src/lex.yy.c	/^static yyconst flex_int16_t yy_def[64] =$/;"	v	file:
yy_delete_buffer	src/lex.yy.c	/^    void yy_delete_buffer (YY_BUFFER_STATE  b )$/;"	f
yy_did_buffer_switch_on_eof	src/lex.yy.c	/^static int yy_did_buffer_switch_on_eof;$/;"	v	file:
yy_ec	src/lex.yy.c	/^static yyconst flex_int32_t yy_ec[256] =$/;"	v	file:
yy_fatal_error	src/lex.yy.c	/^static void yy_fatal_error (yyconst char* msg )$/;"	f	file:
yy_fill_buffer	src/lex.yy.c	/^	int yy_fill_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_flex_debug	src/lex.yy.c	/^int yy_flex_debug = 0;$/;"	v
yy_flex_strlen	src/lex.yy.c	/^static int yy_flex_strlen (yyconst char * s )$/;"	f	file:
yy_flex_strncpy	src/lex.yy.c	/^static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )$/;"	f	file:
yy_flush_buffer	src/lex.yy.c	/^    void yy_flush_buffer (YY_BUFFER_STATE  b )$/;"	f
yy_get_next_buffer	src/lex.yy.c	/^static int yy_get_next_buffer (void)$/;"	f	file:
yy_get_previous_state	src/lex.yy.c	/^    static yy_state_type yy_get_previous_state (void)$/;"	f	file:
yy_hold_char	src/lex.yy.c	/^static char yy_hold_char;$/;"	v	file:
yy_init	src/lex.yy.c	/^static int yy_init = 0;		\/* whether we need to initialize *\/$/;"	v	file:
yy_init_buffer	src/lex.yy.c	/^    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )$/;"	f	file:
yy_init_globals	src/lex.yy.c	/^static int yy_init_globals (void)$/;"	f	file:
yy_input_file	src/lex.yy.c	/^	FILE *yy_input_file;$/;"	m	struct:yy_buffer_state	file:
yy_is_interactive	src/lex.yy.c	/^	int yy_is_interactive;$/;"	m	struct:yy_buffer_state	file:
yy_is_our_buffer	src/lex.yy.c	/^	int yy_is_our_buffer;$/;"	m	struct:yy_buffer_state	file:
yy_last_accepting_cpos	src/lex.yy.c	/^static char *yy_last_accepting_cpos;$/;"	v	file:
yy_last_accepting_state	src/lex.yy.c	/^static yy_state_type yy_last_accepting_state;$/;"	v	file:
yy_load_buffer_state	src/lex.yy.c	/^static void yy_load_buffer_state  (void)$/;"	f	file:
yy_meta	src/lex.yy.c	/^static yyconst flex_int32_t yy_meta[15] =$/;"	v	file:
yy_n_chars	src/lex.yy.c	/^	int yy_n_chars;$/;"	m	struct:yy_buffer_state	file:
yy_n_chars	src/lex.yy.c	/^static int yy_n_chars;		\/* number of characters read into yy_ch_buf *\/$/;"	v	file:
yy_new_buffer	src/lex.yy.c	317;"	d	file:
yy_nxt	src/lex.yy.c	/^	flex_int32_t yy_nxt;$/;"	m	struct:yy_trans_info	file:
yy_nxt	src/lex.yy.c	/^static yyconst flex_int16_t yy_nxt[157] =$/;"	v	file:
yy_reduce_print	src/y.tab.c	/^yy_reduce_print (YYSTYPE *yyvsp, int yyrule)$/;"	f	file:
yy_scan_buffer	src/lex.yy.c	/^YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )$/;"	f
yy_scan_bytes	src/lex.yy.c	/^YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )$/;"	f
yy_scan_string	src/lex.yy.c	/^YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )$/;"	f
yy_set_bol	src/lex.yy.c	329;"	d	file:
yy_set_interactive	src/lex.yy.c	319;"	d	file:
yy_size_t	src/lex.yy.c	/^typedef size_t yy_size_t;$/;"	t	file:
yy_stack_print	src/y.tab.c	/^yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)$/;"	f	file:
yy_start	src/lex.yy.c	/^static int yy_start = 0;	\/* start state number *\/$/;"	v	file:
yy_state_type	src/lex.yy.c	/^typedef int yy_state_type;$/;"	t	file:
yy_switch_to_buffer	src/lex.yy.c	/^    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )$/;"	f
yy_symbol_print	src/y.tab.c	/^yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_symbol_value_print	src/y.tab.c	/^yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)$/;"	f	file:
yy_trans_info	src/lex.yy.c	/^struct yy_trans_info$/;"	s	file:
yy_try_NUL_trans	src/lex.yy.c	/^    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )$/;"	f	file:
yy_verify	src/lex.yy.c	/^	flex_int32_t yy_verify;$/;"	m	struct:yy_trans_info	file:
yyalloc	src/lex.yy.c	/^void *yyalloc (yy_size_t  size )$/;"	f
yyalloc	src/y.tab.c	/^union yyalloc$/;"	u	file:
yychar	src/y.tab.c	/^int yychar;$/;"	v
yycheck	src/y.tab.c	/^static const yytype_int8 yycheck[] =$/;"	v	file:
yyclearin	src/y.tab.c	580;"	d	file:
yyconst	src/lex.yy.c	106;"	d	file:
yyconst	src/lex.yy.c	108;"	d	file:
yydebug	src/y.tab.c	/^int yydebug;$/;"	v
yydefact	src/y.tab.c	/^static const yytype_uint8 yydefact[] =$/;"	v	file:
yydefgoto	src/y.tab.c	/^static const yytype_int8 yydefgoto[] =$/;"	v	file:
yydestruct	src/y.tab.c	/^yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)$/;"	f	file:
yyensure_buffer_stack	src/lex.yy.c	/^static void yyensure_buffer_stack (void)$/;"	f	file:
yyerrok	src/y.tab.c	579;"	d	file:
yyerror	src/lex.yy.c	/^int yyerror(char * msg)$/;"	f
yyfree	src/lex.yy.c	/^void yyfree (void * ptr )$/;"	f
yyget_debug	src/lex.yy.c	/^int yyget_debug  (void)$/;"	f
yyget_in	src/lex.yy.c	/^FILE *yyget_in  (void)$/;"	f
yyget_leng	src/lex.yy.c	/^int yyget_leng  (void)$/;"	f
yyget_lineno	src/lex.yy.c	/^int yyget_lineno  (void)$/;"	f
yyget_out	src/lex.yy.c	/^FILE *yyget_out  (void)$/;"	f
yyget_text	src/lex.yy.c	/^char *yyget_text  (void)$/;"	f
yyin	src/lex.yy.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yyinput	src/lex.yy.c	/^    static int yyinput (void)$/;"	f	file:
yyleng	src/lex.yy.c	/^int yyleng;$/;"	v
yyless	src/lex.yy.c	175;"	d	file:
yyless	src/lex.yy.c	1768;"	d	file:
yyless	src/lex.yy.c	1769;"	d	file:
yylex_destroy	src/lex.yy.c	/^int yylex_destroy  (void)$/;"	f
yylineno	src/lex.yy.c	/^int yylineno = 1;$/;"	v
yylval	src/y.tab.c	/^YYSTYPE yylval;$/;"	v
yymore	src/lex.yy.c	501;"	d	file:
yynerrs	src/y.tab.c	/^int yynerrs;$/;"	v
yyout	src/lex.yy.c	/^FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;$/;"	v
yypact	src/y.tab.c	/^static const yytype_int8 yypact[] =$/;"	v	file:
yyparse	src/y.tab.c	/^yyparse (void *YYPARSE_PARAM)$/;"	f
yypgoto	src/y.tab.c	/^static const yytype_int8 yypgoto[] =$/;"	v	file:
yypop_buffer_state	src/lex.yy.c	/^void yypop_buffer_state (void)$/;"	f
yyprhs	src/y.tab.c	/^static const yytype_uint8 yyprhs[] =$/;"	v	file:
yypush_buffer_state	src/lex.yy.c	/^void yypush_buffer_state (YY_BUFFER_STATE new_buffer )$/;"	f
yyr1	src/y.tab.c	/^static const yytype_uint8 yyr1[] =$/;"	v	file:
yyr2	src/y.tab.c	/^static const yytype_uint8 yyr2[] =$/;"	v	file:
yyrealloc	src/lex.yy.c	/^void *yyrealloc  (void * ptr, yy_size_t  size )$/;"	f
yyrestart	src/lex.yy.c	/^    void yyrestart  (FILE * input_file )$/;"	f
yyrhs	src/y.tab.c	/^static const yytype_int8 yyrhs[] =$/;"	v	file:
yyrline	src/y.tab.c	/^static const yytype_uint8 yyrline[] =$/;"	v	file:
yyset_debug	src/lex.yy.c	/^void yyset_debug (int  bdebug )$/;"	f
yyset_in	src/lex.yy.c	/^void yyset_in (FILE *  in_str )$/;"	f
yyset_lineno	src/lex.yy.c	/^void yyset_lineno (int  line_number )$/;"	f
yyset_out	src/lex.yy.c	/^void yyset_out (FILE *  out_str )$/;"	f
yyss_alloc	src/y.tab.c	/^  yytype_int16 yyss_alloc;$/;"	m	union:yyalloc	file:
yystos	src/y.tab.c	/^static const yytype_uint8 yystos[] =$/;"	v	file:
yystpcpy	src/y.tab.c	/^yystpcpy (char *yydest, const char *yysrc)$/;"	f	file:
yystpcpy	src/y.tab.c	878;"	d	file:
yystrlen	src/y.tab.c	/^yystrlen (const char *yystr)$/;"	f	file:
yystrlen	src/y.tab.c	855;"	d	file:
yystype	src/y.tab.c	182;"	d	file:
yystype	src/y.tab.h	78;"	d
yysyntax_error	src/y.tab.c	/^yysyntax_error (char *yyresult, int yystate, int yychar)$/;"	f	file:
yytable	src/y.tab.c	/^static const yytype_uint8 yytable[] =$/;"	v	file:
yyterminate	src/lex.yy.c	693;"	d	file:
yytext	src/lex.yy.c	/^char *yytext;$/;"	v
yytext_ptr	src/lex.yy.c	354;"	d	file:
yytname	src/y.tab.c	/^static const char *const yytname[] =$/;"	v	file:
yytnamerr	src/y.tab.c	/^yytnamerr (char *yyres, const char *yystr)$/;"	f	file:
yytokentype	src/y.tab.c	/^   enum yytokentype {$/;"	g	file:
yytokentype	src/y.tab.h	/^   enum yytokentype {$/;"	g
yytoknum	src/y.tab.c	/^static const yytype_uint16 yytoknum[] =$/;"	v	file:
yytranslate	src/y.tab.c	/^static const yytype_uint8 yytranslate[] =$/;"	v	file:
yytype_int16	src/y.tab.c	/^typedef YYTYPE_INT16 yytype_int16;$/;"	t	file:
yytype_int16	src/y.tab.c	/^typedef short int yytype_int16;$/;"	t	file:
yytype_int8	src/y.tab.c	/^typedef YYTYPE_INT8 yytype_int8;$/;"	t	file:
yytype_int8	src/y.tab.c	/^typedef short int yytype_int8;$/;"	t	file:
yytype_int8	src/y.tab.c	/^typedef signed char yytype_int8;$/;"	t	file:
yytype_uint16	src/y.tab.c	/^typedef YYTYPE_UINT16 yytype_uint16;$/;"	t	file:
yytype_uint16	src/y.tab.c	/^typedef unsigned short int yytype_uint16;$/;"	t	file:
yytype_uint8	src/y.tab.c	/^typedef YYTYPE_UINT8 yytype_uint8;$/;"	t	file:
yytype_uint8	src/y.tab.c	/^typedef unsigned char yytype_uint8;$/;"	t	file:
yyunput	src/lex.yy.c	/^    static void yyunput (int c, register char * yy_bp )$/;"	f	file:
yyvs_alloc	src/y.tab.c	/^  YYSTYPE yyvs_alloc;$/;"	m	union:yyalloc	file:
yywrap	src/configure	/^yywrap()$/;"	f
yywrap	src/lex.yy.c	/^int yywrap()$/;"	f
